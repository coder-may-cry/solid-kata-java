<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Kata SOLID</title>

		<link rel="stylesheet" href="dist/reveal.css">
		<link id="csstheme" rel="stylesheet" href="custom/theme/mytheme-black.css">
		<link id="mycss" rel="stylesheet" href="custom/css/mycss.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
  					<textarea data-template>
						## Kata principes SOLID

						![Kata illustration](images/kata.png) <!-- .element: height="550px" -->

						---

						## Principes SOLID

						<table>
							<tr><td>Responsabilité unique     </td><td><strong>S</strong>ingle responsibility principle</td></tr>
							<tr><td>Ouvert/fermé              </td><td><strong>O</strong>pen/closed principle</td></tr>
							<tr><td>Substitution de Liskov    </td><td><strong>L</strong>iskov substitution principle</td></tr>
							<tr><td>Ségrégation des interfaces</td><td><strong>I</strong>nterface segregation</td></tr>
							<tr><td>Inversion des dépendances </td><td><strong>D</strong>ependency inversion</td></tr>
						</table>

						Note:

						Ensemble de principes de conception applicables en **programmation Objet**

						---

						## Responsabilité unique

						![Single responsibility](images/solid/single-responsibility.png) <!-- .element: height="550px" -->

						Note:

						Symptômes : classes "divines", classes difficiles à tester unitairement avec des mocks dans tous les sens

						CRC (Class-Responsibility-Collaboration) Cards, ...

						---

						## Responsabilité unique // BAD

						```java
							public class UserService {
								private Database database;
								private SmtpClient smtpClient;
								private MailFormatter formatter;

								public void Register(String email, String password) {
									byte[] hash = addSaltAndHash(password);
									User user = new User(email, hash);
									// Do anything required
									database.save(user);
									smtpClient.send(buildMessage(email));
									// Deal with send failures ??
								}

								private MailMessage buildMessage(String email) {
									String body = formatter.format(email);
									new MailMessage("donotreply@company.com", email, body);
								}
							}
						```

						Note:

						Si je dois changer le format du mail, gérer une bufferisation des mails, ... , je vais devoir modifier le UserService.

						Solution:
						* séparer la logique d'enregistrement d'un nouvel utilisateur, de celle de la gestion des notifications.
						* créer un MailService qui prend la responsabilité de gérer le serveur Smtp, le formatage du mail, ...

						---

						## Responsabilité unique // GOOD

						```java
							public class UserService {
								private Database database;
								@Autowired
								private MailService mailService;

								public void Register(string email, string password) {
									byte[] hash = addSaltAndHash(password);
									User user = new User(email, hash);
									// Do anything required
									database.Save(user);
									mailService.sendRegistrationNotification(email);
								}
							}
						```

						---

						## Responsabilité unique
						![Responsabilité unique](images/lets-code.png) <!-- .element: height="400px" -->

						---

						## Ouvert/fermé

						![Open/closed](images/solid/open-closed.png) <!-- .element: height="550px" -->

						Note:

						Les classes, méthodes, ... devraient être ouvertes à l'extension, mais fermées à la modification

						Symptômes : instanceOf, switch

						---

						## Ouvert/fermé // BAD

						```java
							public class MailService {
								public void send(Event event, String email) {
									String body = event.getUserMessage();
									smtpClient.send(MailMessage("donotreply@company.com", email, body));
								}
							}

							public class SuspiciousLoginEvent implements Event {
								@Override
								public String getUserMessage() {
									"A suspicious login attempt was logged from " + country;
								}
							}
						```

						Note:

						Il n'est pas possible d'étendre la logique de notification sans modifier la méthode send.

						Solution :
						* abstraction, polymorphisme
						* services/beans (couche métier toussa toussa)

						---

						## Ouvert/fermé // GOOD

						```java
						    public class MailService {
								public void sendNotification(Event event, String email) {
									String body;
									if (event instanceof RegistrationEvent) {
										body = "Welcome";
									} else if (event instanceof SuspiciousLoginEvent) {
										body = "A suspicious login attempt was logged from "
											+ ((SuspiciousLoginEvent) event).getCountry();
									} else {
										throw new UnsupportedOperationException(event.getClass().getName());
									}
									smtpClient.send(MailMessage("donotreply@company.com", email, body));
								}
							}
						```

						Note:

						Autre exemple un peu plus complexe avec une intrication plus complexe à "casser" :

						```java
						    public class MailService {
								public void send(Event event, String email) {
									String body = event.getUserMessage();
									smtpClient.send(MailMessage("donotreply@company.com", email, body));
								}
							}

							public class SuspiciousLoginEvent implements Event {
								@Override
								public String getUserMessage() {
									"A suspicious login attempt was logged from " + country;
								}
							}
						```

						Il n'est pas possible de changer la logique d'affichage ou en ajouter une sans modifier chacune des expressions.

						Solution :
						* pattern visiteur : permet de découpler la logique de parcours de graphe du traitement d'affichage (on détaille ???)

						---

						## Ouvert/fermé
						![Ouvert/fermé](images/lets-code.png) <!-- .element: height="400px" -->

						---


						## Substitution de Liskov

						![Liskov](images/solid/liskov.png) <!-- .element: height="450px" -->

						> Si `q(x)` est une propriété démontrable pour tout objet `x` de type `T`, alors `q(y)` est vraie pour tout objet `y` de type `S` tel que `S` est un sous-type de `T` ([source](https://fr.wikipedia.org/wiki/Principe_de_substitution_de_Liskov))

						Note:

						Si T' est un sous-type de T, alors toute instance de T doit pouvoir être remplacée par une instance de T' sans que cela ne corrompe le programme

						-> L'exemple présenté sur le Open/Closed principle viole également le principe de Liskov en réalité...

						---

						## Substitution de Liskov // BAD

						```java
						    public interface User {
								String getLogin();
								RemunerationMode getRemunerationMode();
							}

							public class Client implements User {
								// ...

								@Override
								public RemunerationMode getRemunerationMode() {
									return null;
								}
							}
						```

						Note:

						---

						## Substitution de Liskov // GOOD

						```java
						    public interface User {
								String getLogin();
							}

							public interface Employee extends User {
								RemunerationMode getRemunerationMode();
							}

							public class Client implements User {
							}

							public class Manager implements Employee {
							}
						```

						Note:

						La notion de "est un" qui parait évidente dans le monde réel ne l'est pas forcément dans la programmation : un carré est-il un rectangle ??
						Il vaut souvent mieux privilégier la maintenabilité du code à une modélisation "parfaite" du monde réel

						Solutions parmi d'autres:
						* revoir la conception et l'arbre d'héritage
						* ségrégation des interfaces !!
						* utilisation de la composition/délégation plutôt que l'héritage si un comportement n'est en réalité pas réellement partagé par l'ensemble des sous-classes, mais qu'on veut simplement éviter de dupliquer du code

						-> Covariance, contravariance, on détaille ????

						---

						## Substitution de Liskov
						![Substitution de Liskov](images/lets-code.png) <!-- .element: height="400px" -->

						---

						## Ségrégation des interfaces

						![Interface segregation](images/solid/interface-segregation.png) <!-- .element: height="550px" -->

						Note:

						---

						## Ségrégation des interfaces // BAD

						```java
						    public interface MotorVehicle {
								void addFuel(int galons);
								void openDoors();
							}

							public class MotorBike implements MotorVehicle {
								@Override
								public void addFuel() {
									// OK
								}

								@Override
								public void openDoors() {
									// What the fuck ??!!
									// Can I really do that without violating Liskov principle ?
								}
							}
						```

						Note:

						---

						## Ségrégation des interfaces // GOOD

						```java
						    public interface MotorVehicle {
								void addFuel(int galons);
							}
							public interface HasDoors {
								void openDoors();
							}

							public class MotorBike implements MotorVehicle {
								@Override
								public void addFuel() {
									// ...
								}
							}
							public class Truck implements MotorVehicle, HasDoors {
								@Override
								public void addFuel() {
									// ...
								}

								@Override
								public void openDoors() {
									// ...
								}
							}
						```

						Note:

						-> Il reste possible de factoriser le code du addFuel... Délégation, classes abstraites, ...

						---

						## Ségrégation des interfaces
						![Ségrégation des interfaces](images/lets-code.png) <!-- .element: height="400px" -->

						---

						## Inversion des dépendances

						![Dependency inversion](images/solid/dependency-inversion.png) <!-- .element: height="550px" -->

						Note:

						---

						## Inversion des dépendances // exemple

						![](images/dependency-inversion.png)

						Note:

						---

						## Inversion des dépendances
						![Inversion des dépendances](images/lets-code.png) <!-- .element: height="400px" -->

						---
  					</textarea>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				center: false,
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
